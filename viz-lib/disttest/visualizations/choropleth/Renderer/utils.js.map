{"version":3,"sources":["../../../../src/visualizations/choropleth/Renderer/utils.ts"],"names":["darkenColor","color","darken","hex","createNumberFormatter","format","placeholder","formatter","value","prepareData","data","keyColumn","valueColumn","result","item","parseFloat","code","undefined","prepareFeatureProperties","feature","valueFormatted","targetField","properties","key","datum","getValueForFeature","getColorByValue","limits","colors","defaultColor","i","length","createScale","features","options","values","isFinite","legend","steps","Math","min","max","limit","chroma","clusteringMode","scale","index","reverse"],"mappings":"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","sourcesContent":["import { isString, isObject, isFinite, each, map, extend, uniq, filter, first } from \"lodash\";\nimport chroma from \"chroma-js\";\nimport { createNumberFormatter as createFormatter } from \"@/lib/value-format\";\n\nexport function darkenColor(color: any) {\n  return chroma(color)\n    .darken()\n    .hex();\n}\n\nexport function createNumberFormatter(format: any, placeholder: any) {\n  const formatter = createFormatter(format);\n  return (value: any) => {\n    if (isFinite(value)) {\n      return formatter(value);\n    }\n    return placeholder;\n  };\n}\n\nexport function prepareData(data: any, keyColumn: any, valueColumn: any) {\n  if (!keyColumn || !valueColumn) {\n    return {};\n  }\n\n  const result = {};\n  each(data, item => {\n    if (item[keyColumn]) {\n      const value = parseFloat(item[valueColumn]);\n      // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n      result[item[keyColumn]] = {\n        code: item[keyColumn],\n        value: isFinite(value) ? value : undefined,\n        item,\n      };\n    }\n  });\n  return result;\n}\n\nexport function prepareFeatureProperties(feature: any, valueFormatted: any, data: any, targetField: any) {\n  const result = {};\n  each(feature.properties, (value, key) => {\n    // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n    result[\"@@\" + key] = value;\n  });\n  // @ts-expect-error ts-migrate(7053) FIXME: Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n  result[\"@@value\"] = valueFormatted;\n  const datum = data[feature.properties[targetField]] || {};\n  return extend(result, datum.item);\n}\n\nexport function getValueForFeature(feature: any, data: any, targetField: any) {\n  const code = feature.properties[targetField];\n  if (isString(code) && isObject(data[code])) {\n    return data[code].value;\n  }\n  return undefined;\n}\n\nexport function getColorByValue(value: any, limits: any, colors: any, defaultColor: any) {\n  if (isFinite(value)) {\n    for (let i = 0; i < limits.length; i += 1) {\n      if (value <= limits[i]) {\n        return colors[i];\n      }\n    }\n  }\n  return defaultColor;\n}\n\nexport function createScale(features: any, data: any, options: any) {\n  // Calculate limits\n  const values = uniq(\n    filter(\n      map(features, feature => getValueForFeature(feature, data, options.targetField)),\n      isFinite\n    )\n  );\n  if (values.length === 0) {\n    return {\n      limits: [],\n      colors: [],\n      legend: [],\n    };\n  }\n  const steps = Math.min(values.length, options.steps);\n  if (steps === 1) {\n    return {\n      limits: values,\n      colors: [options.colors.max],\n      legend: [\n        {\n          color: options.colors.max,\n          limit: first(values),\n        },\n      ],\n    };\n  }\n  const limits = chroma.limits(values, options.clusteringMode, steps - 1);\n\n  // Create color buckets\n  const colors = chroma.scale([options.colors.min, options.colors.max]).colors(limits.length);\n\n  // Group values for legend\n  const legend = map(colors, (color, index) => ({\n    color,\n    limit: limits[index],\n  })).reverse();\n\n  return { limits, colors, legend };\n}\n"],"file":"utils.js"}